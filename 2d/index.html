
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Grid & Vector Transformation Visualizer</title>
    <link rel="stylesheet" href="../css/2d.css">
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">← Back to Navigation</a>
        <h1>2D Grid & Vector Transformation Visualizer</h1>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #007bff;"></div>
                <span>Original Grid</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Transformed Grid</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #28a745;"></div>
                <span>Vector</span>
            </div>
        </div>
        
        <div class="main-layout">
            <div class="controls">
            <div class="control-group">
                <h3>Vector Input</h3>
                <div class="vector-input">
                    <label>X: <input type="number" id="vectorX" value="2" step="0.1" onchange="updateVector()"></label>
                    <label>Y: <input type="number" id="vectorY" value="1" step="0.1" onchange="updateVector()"></label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Transformation Matrix (2x2)</h3>
                <div>
                    <input type="number" id="a11" value="1" step="0.1" onchange="applyTransformation()"> <input type="number" id="a12" value="0" step="0.1" onchange="applyTransformation()"><br>
                    <input type="number" id="a21" value="0" step="0.1" onchange="applyTransformation()"> <input type="number" id="a22" value="1" step="0.1" onchange="applyTransformation()">
                </div>
                <div class="transformation-info" id="transformationInfo">
                    <div>Matrix: [1.0 0.0]</div>
                    <div>        [0.0 1.0]</div>
                    <div>Input: [2.0, 1.0]</div>
                    <div>Output: [2.0, 1.0]</div>
                    <div>Determinant: 1.00</div>
                </div>
                <button onclick="resetGrid()">Reset</button>
            </div>
            
            <div class="control-group">
                <h3>Preset Transformations</h3>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setPreset('identity')">Identity</button>
                    <button class="preset-btn" onclick="setPreset('rotation90')">Rotation 90°</button>
                    <button class="preset-btn" onclick="setPreset('rotation45')">Rotation 45°</button>
                    <button class="preset-btn" onclick="setPreset('scaling')">Scaling (2x)</button>
                    <button class="preset-btn" onclick="setPreset('shear')">Shear</button>
                    <button class="preset-btn" onclick="setPreset('reflection')">Reflection</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Grid Settings</h3>
                <label>Grid Size: <input type="number" id="gridSize" value="8" min="3" max="15" onchange="updateGrid()"></label><br>
                <label>Grid Spacing: <input type="number" id="gridSpacing" value="50" min="30" max="100" onchange="updateGrid()"></label>
            </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gridCanvas" width="800" height="600"></canvas>
                <div class="zoom-controls">
                    <button onclick="zoomIn()">+</button>
                    <button onclick="zoomOut()">-</button>
                    <button onclick="resetView()">Reset View</button>
                    <div class="zoom-info" id="zoomInfo">Zoom: 1.00x</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        
        // Viewport transformation variables
        let viewport = {
            scale: 1.0,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };
        
        let gridPoints = [];
        let transformedPoints = [];
        let currentMatrix = [[1, 0], [0, 1]];
        let currentVector = [2, 1];
        let transformedVector = [2, 1];
        
        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            // Remove the canvas center offset first, then the viewport offset, then scale
            const worldX = (screenX - canvas.width / 2 - viewport.offsetX) / viewport.scale;
            const worldY = -(screenY - canvas.height / 2 - viewport.offsetY) / viewport.scale;
            return [worldX, worldY];
        }
        
        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            const screenX = worldX * viewport.scale + viewport.offsetX + canvas.width / 2;
            const screenY = -worldY * viewport.scale + viewport.offsetY + canvas.height / 2;
            return [screenX, screenY];
        }
        
        // Apply viewport transformation to context
        function applyViewportTransform() {
            ctx.save();
            // First translate to center the coordinate system
            ctx.translate(canvas.width / 2, canvas.height / 2);
            // Then apply the viewport offset and scale
            ctx.translate(viewport.offsetX, viewport.offsetY);
            ctx.scale(viewport.scale, -viewport.scale); // Flip Y-axis for mathematical coordinates
        }
        
        // Restore context after viewport transformation
        function restoreViewportTransform() {
            ctx.restore();
        }
        
        // Zoom functions
        function zoomIn() {
            viewport.scale *= 1.2;
            updateZoomInfo();
            drawGrid();
        }
        
        function zoomOut() {
            viewport.scale /= 1.2;
            updateZoomInfo();
            drawGrid();
        }
        
        function resetView() {
            viewport.scale = 1.0;
            viewport.offsetX = 0;
            viewport.offsetY = 0;
            updateZoomInfo();
            drawGrid();
        }
        
        function updateZoomInfo() {
            document.getElementById('zoomInfo').textContent = `Zoom: ${viewport.scale.toFixed(2)}x`;
        }
        
        function transformPoint(point, matrix) {
            const [x, y] = point;
            const [[a, b], [c, d]] = matrix;
            return [a * x + b * y, c * x + d * y];
        }
        
        // Draw arrow
        function drawArrow(startX, startY, endX, endY, color, lineWidth = 3) {
            const headLength = 15 / viewport.scale;
            const angle = Math.atan2(endY - startY, endX - startX);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth / viewport.scale;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw arrow head
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), 
                      endY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), 
                      endY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }
        
        function initializeGrid() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const spacing = parseInt(document.getElementById('gridSpacing').value);
            
            gridPoints = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    gridPoints.push([i * spacing, j * spacing]);
                }
            }
            updateTransformedPoints();
            updateTransformedVector();
            drawGrid();
        }
        
        function updateTransformedPoints() {
            transformedPoints = gridPoints.map(point => transformPoint(point, currentMatrix));
        }
        
        function updateTransformedVector() {
            transformedVector = transformPoint(currentVector, currentMatrix);
        }
        
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            applyViewportTransform();
            
            // Draw coordinate axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2 / viewport.scale;
            ctx.beginPath();
            // X-axis (horizontal line through origin)
            ctx.moveTo(-canvas.width / viewport.scale, 0);
            ctx.lineTo(canvas.width / viewport.scale, 0);
            // Y-axis (vertical line through origin)
            ctx.moveTo(0, -canvas.height / viewport.scale);
            ctx.lineTo(0, canvas.height / viewport.scale);
            ctx.stroke();
            
            // Draw original grid lines
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1 / viewport.scale;
            const spacing = parseInt(document.getElementById('gridSpacing').value);
            const gridSize = parseInt(document.getElementById('gridSize').value);
            
            // Draw vertical lines
            for (let i = -gridSize; i <= gridSize; i++) {
                const x = i * spacing;
                ctx.beginPath();
                ctx.moveTo(x, -gridSize * spacing);
                ctx.lineTo(x, gridSize * spacing);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let j = -gridSize; j <= gridSize; j++) {
                const y = j * spacing;
                ctx.beginPath();
                ctx.moveTo(-gridSize * spacing, y);
                ctx.lineTo(gridSize * spacing, y);
                ctx.stroke();
            }
            
            // Draw transformed grid lines
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 1 / viewport.scale;
            
            // Draw transformed vertical lines
            for (let i = -gridSize; i <= gridSize; i++) {
                const originalX = i * spacing;
                const transformedStart = transformPoint([originalX, -gridSize * spacing], currentMatrix);
                const transformedEnd = transformPoint([originalX, gridSize * spacing], currentMatrix);
                
                ctx.beginPath();
                ctx.moveTo(transformedStart[0], transformedStart[1]);
                ctx.lineTo(transformedEnd[0], transformedEnd[1]);
                ctx.stroke();
            }
            
            // Draw transformed horizontal lines
            for (let j = -gridSize; j <= gridSize; j++) {
                const originalY = j * spacing;
                const transformedStart = transformPoint([-gridSize * spacing, originalY], currentMatrix);
                const transformedEnd = transformPoint([gridSize * spacing, originalY], currentMatrix);
                
                ctx.beginPath();
                ctx.moveTo(transformedStart[0], transformedStart[1]);
                ctx.lineTo(transformedEnd[0], transformedEnd[1]);
                ctx.stroke();
            }
            
            // Draw original vector
            const vectorStartX = 0;
            const vectorStartY = 0;
            const vectorEndX = currentVector[0] * spacing;
            const vectorEndY = currentVector[1] * spacing;
            drawArrow(vectorStartX, vectorStartY, vectorEndX, vectorEndY, '#28a745', 4);
            
            // Draw transformed vector
            const transformedVectorStartX = 0;
            const transformedVectorStartY = 0;
            const transformedVectorEndX = transformedVector[0] * spacing;
            const transformedVectorEndY = transformedVector[1] * spacing;
            drawArrow(transformedVectorStartX, transformedVectorStartY, 
                     transformedVectorEndX, transformedVectorEndY, '#ffc107', 4);
            
            restoreViewportTransform();
        }
        
        // Mouse event handlers for pan and zoom
        canvas.addEventListener('mousedown', function(e) {
            viewport.isDragging = true;
            viewport.lastX = e.clientX;
            viewport.lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (viewport.isDragging) {
                const deltaX = e.clientX - viewport.lastX;
                const deltaY = e.clientY - viewport.lastY;
                viewport.offsetX += deltaX;
                viewport.offsetY += deltaY;
                viewport.lastX = e.clientX;
                viewport.lastY = e.clientY;
                drawGrid();
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            viewport.isDragging = false;
        });
        
        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert mouse position to world coordinates
            const [worldX, worldY] = screenToWorld(mouseX, mouseY);
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            viewport.scale *= zoomFactor;
            
            // Adjust offset to zoom towards mouse position
            const [newScreenX, newScreenY] = worldToScreen(worldX, worldY);
            viewport.offsetX += mouseX - newScreenX;
            viewport.offsetY += mouseY - newScreenY;
            
            updateZoomInfo();
            drawGrid();
        });
        
        function updateVector() {
            const x = parseFloat(document.getElementById('vectorX').value);
            const y = parseFloat(document.getElementById('vectorY').value);
            currentVector = [x, y];
            updateTransformedVector();
            drawGrid();
        }
        
        function applyTransformation() {
            const a11 = parseFloat(document.getElementById('a11').value);
            const a12 = parseFloat(document.getElementById('a12').value);
            const a21 = parseFloat(document.getElementById('a21').value);
            const a22 = parseFloat(document.getElementById('a22').value);
            
            currentMatrix = [[a11, a12], [a21, a22]];
            updateTransformedPoints();
            updateTransformedVector();
            drawGrid();
            updateMatrixDisplay();
        }
        
        function resetGrid() {
            currentMatrix = [[1, 0], [0, 1]];
            document.getElementById('a11').value = 1;
            document.getElementById('a12').value = 0;
            document.getElementById('a21').value = 0;
            document.getElementById('a22').value = 1;
            updateTransformedPoints();
            updateTransformedVector();
            drawGrid();
            updateMatrixDisplay();
        }
        
        function updateGrid() {
            initializeGrid();
        }
        
        function calculateDeterminant(matrix) {
            const [[a11, a12], [a21, a22]] = matrix;
            return a11 * a22 - a12 * a21;
        }
        
        function updateMatrixDisplay() {
            const [[a11, a12], [a21, a22]] = currentMatrix;
            const determinant = calculateDeterminant(currentMatrix);
            const [vectorX, vectorY] = currentVector;
            
            // Calculate the transformed vector
            const transformedX = a11 * vectorX + a12 * vectorY;
            const transformedY = a21 * vectorX + a22 * vectorY;
            
            // Update the transformation info with all information
            const transformationInfo = document.getElementById('transformationInfo');
            if (transformationInfo) {
                transformationInfo.innerHTML = 
                    `<div>Matrix: [${a11.toFixed(1)} ${a12.toFixed(1)}]</div>
                     <div>        [${a21.toFixed(1)} ${a22.toFixed(1)}]</div>
                     <div>Input: [${vectorX.toFixed(1)}, ${vectorY.toFixed(1)}]</div>
                     <div>Output: [${transformedX.toFixed(1)}, ${transformedY.toFixed(1)}]</div>
                     <div>Determinant: ${determinant.toFixed(2)}</div>`;
            }
        }
        
        function setPreset(type) {
            let matrix;
            switch(type) {
                case 'identity':
                    matrix = [[1, 0], [0, 1]];
                    break;
                case 'rotation90':
                    matrix = [[0, -1], [1, 0]];
                    break;
                case 'rotation45':
                    const cos45 = Math.cos(Math.PI / 4);
                    const sin45 = Math.sin(Math.PI / 4);
                    matrix = [[cos45, -sin45], [sin45, cos45]];
                    break;
                case 'scaling':
                    matrix = [[2, 0], [0, 2]];
                    break;
                case 'shear':
                    matrix = [[1, 1], [0, 1]];
                    break;
                case 'reflection':
                    matrix = [[-1, 0], [0, 1]];
                    break;
            }
            
            currentMatrix = matrix;
            document.getElementById('a11').value = matrix[0][0];
            document.getElementById('a12').value = matrix[0][1];
            document.getElementById('a21').value = matrix[1][0];
            document.getElementById('a22').value = matrix[1][1];
            
            updateTransformedPoints();
            updateTransformedVector();
            drawGrid();
            updateMatrixDisplay();
        }
        
        window.onload = function() {
            initializeGrid();
            updateMatrixDisplay();
            updateZoomInfo();
        };
    </script>
</body>
</html>
    